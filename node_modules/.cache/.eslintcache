[{"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/index.js":"1","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/reportWebVitals.js":"2","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/App.js":"3","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/Header.js":"4","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/Main.js":"5","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/Footer.js":"6","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/SatSetting.js":"7","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/SatelliteList.js":"8","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/constants.js":"9","/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/WorldMap.js":"10"},{"size":546,"mtime":1654105156890,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1654103561314,"results":"13","hashOfConfig":"12"},{"size":265,"mtime":1654105243191,"results":"14","hashOfConfig":"12"},{"size":445,"mtime":1654103895635,"results":"15","hashOfConfig":"12"},{"size":2208,"mtime":1654382866561,"results":"16","hashOfConfig":"12"},{"size":300,"mtime":1654104131797,"results":"17","hashOfConfig":"12"},{"size":4415,"mtime":1654126643809,"results":"18","hashOfConfig":"12"},{"size":2671,"mtime":1654357177821,"results":"19","hashOfConfig":"12"},{"size":416,"mtime":1656610062302,"results":"20","hashOfConfig":"12"},{"size":7734,"mtime":1654383700248,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"dojsie",{"filePath":"24","messages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42"},"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/index.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/reportWebVitals.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/App.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/Header.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/Main.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/Footer.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/SatSetting.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/SatelliteList.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/constants.js",[],"/Users/Marvin/Developer/LaiOffer/Projects/starlink/src/components/WorldMap.js",["43","44","45"],"import React, {Component} from 'react';\nimport { feature } from 'topojson-client';\nimport axios from 'axios';\nimport { geoKavrayskiy7 } from 'd3-geo-projection';\nimport { geoGraticule, geoPath } from 'd3-geo';\nimport { select as d3Select } from 'd3-selection';\nimport { Spin } from \"antd\";\nimport { schemeCategory10 } from \"d3-scale-chromatic\";\nimport * as d3Scale from \"d3-scale\";\nimport { timeFormat as d3TimeFormat } from \"d3-time-format\";\n\nimport {\n  BASE_URL,\n  WORLD_MAP_URL,\n  SATELLITE_POSITION_URL,\n  SAT_API_KEY\n} from \"../constants\";\n\n\nconst width = 960;\nconst height = 600;\n\nclass WorldMap extends Component {\n    constructor(){\n        super();\n        this.state = {\n            isDrawing: false,\n            isLoading: false\n        }\n        this.map = null;\n        // color range\n        this.color = d3Scale.scaleOrdinal(schemeCategory10);\n        this.refMap = React.createRef();\n        this.refTrack = React.createRef();\n    \n    }\n\n    componentDidMount() {\n        axios.get(WORLD_MAP_URL)\n            .then(res => {\n                const { data } = res;\n                const land = feature(data, data.objects.countries).features;\n                this.generateMap(land);\n            })\n            .catch(e => console.log('err in fecth world map data ', e))\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        if (prevProps.satData !== this.props.satData) {\n            // Step 1: get observer data from props.observerData\n            if (prevProps.satData !== this.props.satData) {\n                const {\n                  latitude,\n                  longitude,\n                  elevation,\n                  altitude,\n                  duration\n                } = this.props.observerData;\n                const endTime = duration * 60;\n                \n                this.setState({\n                    isLoading: true\n                  });\n\n                // Step 2: for each sat, we get id from props.satData\n                // Step 3: for each sat, get its position\n                const urls = this.props.satData.map(sat => {\n                    const { satid } = sat;\n                    const url = `${BASE_URL}/api/${SATELLITE_POSITION_URL}/${satid}/${latitude}/${longitude}/${elevation}/${endTime}/&apiKey=${SAT_API_KEY}`;\n            \n                    return axios.get(url);\n                });\n\n                Promise.all(urls)\n                .then(res => {\n                    const arr = res.map(sat => sat.data);\n                    // we are drawing this path so isDrawing is true\n                    this.setState({\n                        isLoading: false,\n                        isDrawing: true\n                    });\n\n                    if (!prevState.isDrawing) {\n                        this.track(arr);\n                    } else {\n                        const oHint = document.getElementsByClassName(\"hint\")[0];\n                        oHint.innerHTML =\n                        \"Please wait for these satellite animation to finish before selection new ones!\";\n                    }\n                })\n                .catch(e => {\n                    console.log(\"err in fetch satellite position -> \", e.message);\n                });\n            }\n            \n            \n            \n            // step 4: display each position on the map\n        }\n    }\n\n    track = data => {\n        if (!data[0].hasOwnProperty(\"positions\")) {\n            throw new Error(\"no position data\");\n            return;\n          }\n          const len = data[0].positions.length;\n          const { duration } = this.props.observerData;\n          // we need to draw the time on this map\n          const { context2 } = this.map;\n\n          let now = new Date();\n      \n          let i = 0;\n          // display time info on the overlay canvas\n\n          let timer = setInterval(() => {\n            // current time \n            let ct = new Date();\n            \n            // calculate the elapsed time\n            let timePassed = i === 0 ? 0 : ct - now;\n\n            // calculate the actual time\n            let time = new Date(now.getTime() + 60 * timePassed);\n            \n            // clear the previous drawing\n            context2.clearRect(0, 0, width, height);\n      \n            context2.font = \"bold 14px sans-serif\";\n            context2.fillStyle = \"#333\";\n            context2.textAlign = \"center\";\n            context2.fillText(d3TimeFormat(time), width / 2, 10);\n      \n            if (i >= len) {\n              clearInterval(timer);\n              this.setState({ isDrawing: false });\n              const oHint = document.getElementsByClassName(\"hint\")[0];\n              oHint.innerHTML = \"\";\n              return;\n            }\n      \n            data.forEach(sat => {\n              const { info, positions } = sat;\n              this.drawSat(info, positions[i]);\n            });\n      \n            i += 60;\n          }, 1000);\n    }\n\n    drawSat = (sat, pos) => {\n        const { satlongitude, satlatitude } = pos;\n    \n        if (!satlongitude || !satlatitude) return;\n    \n        const { satname } = sat;\n        const nameWithNumber = satname.match(/\\d+/g).join(\"\");\n    \n        const { projection, context2 } = this.map;\n        const xy = projection([satlongitude, satlatitude]);\n    \n        context2.fillStyle = this.color(nameWithNumber);\n        context2.beginPath();\n        context2.arc(xy[0], xy[1], 4, 0, 2 * Math.PI);\n        context2.fill();\n    \n        context2.font = \"bold 11px sans-serif\";\n        context2.textAlign = \"center\";\n        context2.fillText(nameWithNumber, xy[0], xy[1] + 14);\n      };\n    \n\n    generateMap(land){\n        // Step1: get world map shape\n        const projection = geoKavrayskiy7()\n            .scale(170)\n            .translate([width / 2, height / 2])\n            .precision(.1);\n\n        const graticule = geoGraticule();\n\n        // Step2: get canvas\n        const canvas = d3Select(this.refMap.current)\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        const canvas2 = d3Select(this.refTrack.current)\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n\n        const context = canvas.node().getContext(\"2d\");\n        const context2 = canvas2.node().getContext(\"2d\");\n\n        let path = geoPath()\n            .projection(projection)\n            .context(context);\n\n        // Step3: project world map data on the map\n        land.forEach(ele => {\n            context.fillStyle = '#B3DDEF';\n            context.strokeStyle = '#000';\n            context.globalAlpha = 0.7;\n            context.beginPath();\n            path(ele);\n            context.fill();\n            context.stroke();\n\n            context.strokeStyle = 'rgba(220, 220, 220, 0.1)';\n            context.beginPath();\n            path(graticule());\n            context.lineWidth = 0.1;\n            context.stroke();\n\n            context.beginPath();\n            context.lineWidth = 0.5;\n            path(graticule.outline());\n            context.stroke();\n        });\n\n        this.map = {\n            projection: projection,\n            graticule: graticule,\n            context: context,\n            context2: context2\n        };\n      \n    }\n\n    render() {\n        const { isLoading } = this.state;\n        return (\n            <div className=\"map-box\">\n                {isLoading ? (\n                    <div className=\"spinner\">\n                    <Spin tip=\"Loading...\" size=\"large\" />\n                    </div>\n                ) : null}\n                <canvas className=\"map\" ref={this.refMap} />\n                <canvas className=\"track\" ref={this.refTrack} />\n                <div className=\"hint\" />\n            </div>\n        );\n    }\n}\n\nexport default WorldMap;\n\n",{"ruleId":"46","severity":1,"message":"47","line":56,"column":19,"nodeType":"48","messageId":"49","endLine":56,"endColumn":27},{"ruleId":"50","severity":1,"message":"51","line":105,"column":13,"nodeType":"52","messageId":"53","endLine":105,"endColumn":20},{"ruleId":"46","severity":1,"message":"54","line":108,"column":19,"nodeType":"48","messageId":"49","endLine":108,"endColumn":27},"no-unused-vars","'altitude' is assigned a value but never used.","Identifier","unusedVar","no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","'duration' is assigned a value but never used."]